// lib/services/palm_detection_service.dart
// POPRAWIONA WERSJA - sp√≥jne wykrywanie d≈Çoni

import 'dart:math' as math;
import 'dart:convert';
import 'package:camera/camera.dart';
import 'package:flutter/services.dart';
import '../models/palm_analysis.dart';

class PalmDetectionService {
  static final PalmDetectionService _instance =
      PalmDetectionService._internal();
  PalmDetectionService._internal();
  factory PalmDetectionService() => _instance;

  final math.Random _random = math.Random();
  Map<String, dynamic>? _palmTemplate;

  // ‚úÖ POPRAWKA: Przechowywanie stanu wykrywania przez ca≈ÇƒÖ sesjƒô
  bool _currentSessionDetectionState = false;
  int _sessionAttempts = 0;
  String? _currentUserName;
  String? _currentHandType;

  // Reset sesji dla nowego u≈ºytkownika
  void startNewDetectionSession(String userName, String handType) {
    print('üîÑ NOWA SESJA WYKRYWANIA:');
    print('   - U≈ºytkownik: $userName');
    print('   - Typ rƒôki: $handType');

    _currentUserName = userName;
    _currentHandType = handType;
    _sessionAttempts = 0;
    _currentSessionDetectionState = false;
  }

  // ‚úÖ POPRAWKA: Sp√≥jne wykrywanie podczas skanowania
  Future<bool> validatePalmDetection({
    required String handType,
    required String userName,
    bool isTestMode = false,
  }) async {
    // Sprawd≈∫ czy to ta sama sesja
    if (_currentUserName != userName || _currentHandType != handType) {
      startNewDetectionSession(userName, handType);
    }

    _sessionAttempts++;

    print('üîç WALIDACJA WYKRYWANIA D≈ÅONI (pr√≥ba $_sessionAttempts):');
    print('   - U≈ºytkownik: $userName');
    print('   - Typ rƒôki: $handType');
    print('   - Tryb testowy: $isTestMode');
    print('   - Stan sesji: $_currentSessionDetectionState');

    if (isTestMode) {
      // W trybie testowym zawsze sukces po kilku pr√≥bach
      if (_sessionAttempts >= 3) {
        _currentSessionDetectionState = true;
        print(
            '‚úÖ WYKRYWANIE (TEST): Sukces - tryb testowy, pr√≥ba $_sessionAttempts');
        return true;
      } else {
        print(
            '‚è≥ WYKRYWANIE (TEST): Zbieranie danych, pr√≥ba $_sessionAttempts/3');
        return false;
      }
    }

    // ‚úÖ POPRAWKA: Progresywne wykrywanie - szanse rosnƒÖ z czasem
    double baseSuccessChance = 0.3; // 30% na start
    double progressiveBonus =
        (_sessionAttempts - 1) * 0.15; // +15% za ka≈ºdƒÖ pr√≥bƒô
    double maxChance = 0.85; // Maksymalnie 85%

    double finalChance =
        math.min(maxChance, baseSuccessChance + progressiveBonus);

    // Je≈õli ju≈º wykryli≈õmy w tej sesji, utrzymaj wysoki sukces
    if (_currentSessionDetectionState) {
      finalChance = math.max(finalChance, 0.8); // Min 80% je≈õli ju≈º wykryto
    }

    await Future.delayed(const Duration(milliseconds: 500));

    final detectionSuccess = _random.nextDouble() < finalChance;

    if (detectionSuccess) {
      _currentSessionDetectionState = true;
      print(
          '‚úÖ WYKRYWANIE: D≈Ço≈Ñ wykryta (szansa: ${(finalChance * 100).toInt()}%, pr√≥ba: $_sessionAttempts)');
    } else {
      print(
          '‚ùå WYKRYWANIE: Nie wykryto d≈Çoni (szansa: ${(finalChance * 100).toInt()}%, pr√≥ba: $_sessionAttempts)');
    }

    return detectionSuccess;
  }

  // ‚úÖ POPRAWKA: G≈Ç√≥wna metoda analizy - u≈ºywa stanu z sesji wykrywania
  Future<PalmAnalysis?> analyzePalm({
    required String handType,
    required String userName,
    bool isTestMode = false,
  }) async {
    print('üîÆ ROZPOCZYNAM FINALNƒÑ ANALIZƒò D≈ÅONI...');
    print('   - Stan sesji wykrywania: $_currentSessionDetectionState');
    print('   - Liczba pr√≥b w sesji: $_sessionAttempts');

    // ‚úÖ POPRAWKA: U≈ºyj stanu z sesji wykrywania zamiast nowej losowej walidacji
    bool finalDetectionResult;

    if (isTestMode) {
      // W trybie testowym zawsze sukces
      finalDetectionResult = true;
      print('‚úÖ FINALNA ANALIZA (TEST): Wymuszony sukces');
    } else {
      // Sprawd≈∫ czy mieli≈õmy ju≈º sukces w sesji
      if (_currentSessionDetectionState && _sessionAttempts >= 3) {
        // Je≈õli ju≈º wykrywali≈õmy i by≈Ço do≈õƒá pr√≥b, bardzo wysoka szansa sukcesu
        finalDetectionResult = _random.nextDouble() < 0.9; // 90% sukcesu
        print(
            '‚úÖ FINALNA ANALIZA: BazujƒÖc na sesji - wykryto wcze≈õniej (90% szans)');
      } else if (_sessionAttempts >= 5) {
        // Je≈õli by≈Ço du≈ºo pr√≥b, daj szansƒô
        finalDetectionResult = _random.nextDouble() < 0.7; // 70% sukcesu
        print('‚úÖ FINALNA ANALIZA: Du≈ºo pr√≥b - umiarkowana szansa (70%)');
      } else {
        // Niska szansa je≈õli ma≈Ço pr√≥b i nie by≈Ço wykrywania
        finalDetectionResult = _random.nextDouble() < 0.4; // 40% sukcesu
        print('‚ùå FINALNA ANALIZA: Ma≈Ço pr√≥b - niska szansa (40%)');
      }
    }

    if (!finalDetectionResult) {
      print('‚ùå FINALNA ANALIZA: Nie wykryto d≈Çoni w ko≈Ñcowej analizie');
      return null;
    }

    // KROK 2: Za≈Çaduj szablon danych
    await _loadPalmTemplate();

    // KROK 3: Symulacja czasu analizy
    print('‚è≥ Analizujƒô cechy d≈Çoni...');
    await Future.delayed(const Duration(seconds: 2));

    // KROK 4: Generowanie analizy
    final analysis = PalmAnalysis(
      handType: handType,
      handShape: _generateHandShape(),
      fingers: _generateFingers(),
      lines: _generatePalmLines(),
      mounts: _generateMounts(),
      skin: _generateSkinCharacteristics(),
      paznokcie: _generateNails(),
      analysisDate: DateTime.now(),
      userName: userName,
    );

    print('‚úÖ FINALNA ANALIZA ZAKO≈ÉCZONA POMY≈öLNIE');
    print('   - Typ rƒôki: ${analysis.handType}');
    print('   - Element d≈Çoni: ${analysis.handShape.elementType}');

    return analysis;
  }

  // Getter do sprawdzania stanu sesji
  bool get currentSessionDetectionState => _currentSessionDetectionState;
  int get sessionAttempts => _sessionAttempts;

  // Resetuj stan (np. przy zmianie u≈ºytkownika)
  void resetDetectionState() {
    print('üîÑ Reset stanu wykrywania');
    _currentSessionDetectionState = false;
    _sessionAttempts = 0;
    _currentUserName = null;
    _currentHandType = null;
  }

  // Reszta metod pozostaje bez zmian...
  Future<void> _loadPalmTemplate() async {
    if (_palmTemplate == null) {
      try {
        final String jsonString = await rootBundle.loadString(
          'assets/data/palm_analysis_template.json',
        );
        _palmTemplate = json.decode(jsonString);
      } catch (e) {
        print('B≈ÇƒÖd ≈Çadowania szablonu d≈Çoni: $e');
        _palmTemplate = _getDefaultTemplate();
      }
    }
  }

  HandShape _generateHandShape() {
    return HandShape(
      size: _getRandomFromList(_palmTemplate!['hand_shape']['size']),
      form: _getRandomFromList(_palmTemplate!['hand_shape']['form']),
      elementType: _getRandomFromList(
        _palmTemplate!['hand_shape']['element_type'],
      ),
    );
  }

  Fingers _generateFingers() {
    return Fingers(
      length: _getRandomFromList(_palmTemplate!['fingers']['length']),
      flexibility: _getRandomFromList(_palmTemplate!['fingers']['flexibility']),
      palecWskazujacy: _getRandomFromList(
        _palmTemplate!['fingers']['palec_wskazujƒÖcy'],
      ),
      palecSerdeczny: _getRandomFromList(
        _palmTemplate!['fingers']['palec_serdeczny'],
      ),
      kciuk: Thumb(
        typ: _getRandomFromList(_palmTemplate!['fingers']['kciuk']['typ']),
        ustawienie: _getRandomFromList(
          _palmTemplate!['fingers']['kciuk']['ustawienie'],
        ),
      ),
    );
  }

  PalmLines _generatePalmLines() {
    return PalmLines(
      lifeLine: LifeLine(
        dlugosc: _getRandomFromList(
          _palmTemplate!['lines']['life_line']['d≈Çugo≈õƒá'],
        ),
        ksztalt: _getRandomFromList(
          _palmTemplate!['lines']['life_line']['kszta≈Çt'],
        ),
        rozpoczecie: _getRandomFromList(
          _palmTemplate!['lines']['life_line']['rozpoczƒôcie'],
        ),
        przebieg: _getRandomFromList(
          _palmTemplate!['lines']['life_line']['przebieg'],
        ),
      ),
      headLine: HeadLine(
        dlugosc: _getRandomFromList(
          _palmTemplate!['lines']['head_line']['d≈Çugo≈õƒá'],
        ),
        ksztalt: _getRandomFromList(
          _palmTemplate!['lines']['head_line']['kszta≈Çt'],
        ),
        rozpoczecie: _getRandomFromList(
          _palmTemplate!['lines']['head_line']['rozpoczƒôcie'],
        ),
        koniec: _getRandomFromList(
          _palmTemplate!['lines']['head_line']['koniec'],
        ),
      ),
      heartLine: HeartLine(
        dlugosc: _getRandomFromList(
          _palmTemplate!['lines']['heart_line']['d≈Çugo≈õƒá'],
        ),
        ksztalt: _getRandomFromList(
          _palmTemplate!['lines']['heart_line']['kszta≈Çt'],
        ),
        rozpoczecie: _getRandomFromList(
          _palmTemplate!['lines']['heart_line']['rozpoczƒôcie'],
        ),
        znaki: _getRandomFromList(
          _palmTemplate!['lines']['heart_line']['znaki'],
        ),
      ),
      fateLine: FateLine(
        obecnosc: _getRandomFromList(
          _palmTemplate!['lines']['fate_line']['obecno≈õƒá'],
        ),
        rozpoczecie: _getRandomFromList(
          _palmTemplate!['lines']['fate_line']['rozpoczƒôcie'],
        ),
        przebieg: _getRandomFromList(
          _palmTemplate!['lines']['fate_line']['przebieg'],
        ),
      ),
      sunLine: SunLine(
        obecnosc: _getRandomFromList(
          _palmTemplate!['lines']['sun_line']['obecno≈õƒá'],
        ),
        rozpoczecie: _getRandomFromList(
          _palmTemplate!['lines']['sun_line']['rozpoczƒôcie'],
        ),
        przebieg: _getRandomFromList(
          _palmTemplate!['lines']['sun_line']['przebieg'],
        ),
      ),
      healthLine: HealthLine(
        obecnosc: _getRandomFromList(
          _palmTemplate!['lines']['health_line']['obecno≈õƒá'],
        ),
        przebieg: _getRandomFromList(
          _palmTemplate!['lines']['health_line']['przebieg'],
        ),
      ),
      marriageLines: MarriageLines(
        ilosc: _getRandomFromList(
          _palmTemplate!['lines']['marriage_lines']['ilo≈õƒá'],
        ),
        ksztalt: _getRandomFromList(
          _palmTemplate!['lines']['marriage_lines']['kszta≈Çt'],
        ),
        znaki: _getRandomFromList(
          _palmTemplate!['lines']['marriage_lines']['znaki'],
        ),
      ),
      childrenLines: ChildrenLines(
        ilosc: _getRandomFromList(
          _palmTemplate!['lines']['children_lines']['ilo≈õƒá'],
        ),
        intensywnosc: _getRandomFromList(
          _palmTemplate!['lines']['children_lines']['intensywno≈õƒá'],
        ),
      ),
    );
  }

  Mounts _generateMounts() {
    return Mounts(
      mountOfJupiter: _getRandomFromList(
        _palmTemplate!['mounts']['Mount of Jupiter'],
      ),
      mountOfSaturne: _getRandomFromList(
        _palmTemplate!['mounts']['Mount of Saturn'],
      ),
      mountOfApollo: _getRandomFromList(
        _palmTemplate!['mounts']['Mount of Apollo'],
      ),
      mountOfMercury: _getRandomFromList(
        _palmTemplate!['mounts']['Mount of Mercury'],
      ),
      mountOfVenus: _getRandomFromList(
        _palmTemplate!['mounts']['Mount of Venus'],
      ),
      mountOfMarsUpper: _getRandomFromList(
        _palmTemplate!['mounts']['Mount of Mars (upper)'],
      ),
      mountOfMarsLower: _getRandomFromList(
        _palmTemplate!['mounts']['Mount of Mars (lower)'],
      ),
      mountOfMoon: _getRandomFromList(
        _palmTemplate!['mounts']['Mount of Moon'],
      ),
    );
  }

  SkinCharacteristics _generateSkinCharacteristics() {
    return SkinCharacteristics(
      tekstura: _getRandomFromList(_palmTemplate!['skin']['tekstura']),
      wilgotnosc: _getRandomFromList(_palmTemplate!['skin']['wilgotno≈õƒá']),
      kolor: _getRandomFromList(_palmTemplate!['skin']['kolor']),
    );
  }

  Nails _generateNails() {
    return Nails(
      dlugosc: _getRandomFromList(_palmTemplate!['paznokcie']['d≈Çugo≈õƒá']),
      ksztalt: _getRandomFromList(_palmTemplate!['paznokcie']['kszta≈Çt']),
      kolor: _getRandomFromList(_palmTemplate!['paznokcie']['kolor']),
    );
  }

  String _getRandomFromList(List<dynamic> list) {
    if (list.isEmpty) return 'nieznane';
    return list[_random.nextInt(list.length)].toString();
  }

  Map<String, dynamic> _getDefaultTemplate() {
    return {
      'hand_shape': {
        'size': ['≈õrednia'],
        'form': ['prostokƒÖtna'],
        'element_type': ['ziemia'],
      },
      'fingers': {
        'length': ['proporcjonalne'],
        'flexibility': ['giƒôtkie'],
        'palec_wskazujƒÖcy': ['normalny'],
        'palec_serdeczny': ['r√≥wny'],
        'kciuk': {
          'typ': ['mocny'],
          'ustawienie': ['normalnie osadzony'],
        },
      },
      'lines': {
        'life_line': {
          'd≈Çugo≈õƒá': ['≈õrednia'],
          'kszta≈Çt': ['g≈Çƒôboka'],
          'rozpoczƒôcie': ['blisko kciuka'],
          'przebieg': ['przylega do kciuka'],
        },
        'head_line': {
          'd≈Çugo≈õƒá': ['≈õrednia'],
          'kszta≈Çt': ['prosta'],
          'rozpoczƒôcie': ['≈ÇƒÖczy siƒô z liniƒÖ ≈ºycia'],
          'koniec': ['wskazuje prosto'],
        },
        'heart_line': {
          'd≈Çugo≈õƒá': ['≈õrednia'],
          'kszta≈Çt': ['prosta'],
          'rozpoczƒôcie': ['pod palcem wskazujƒÖcym'],
          'znaki': ['czysta'],
        },
        'fate_line': {
          'obecno≈õƒá': ['jest'],
          'rozpoczƒôcie': ['od nadgarstka'],
          'przebieg': ['prosta'],
        },
        'sun_line': {
          'obecno≈õƒá': ['jest'],
          'rozpoczƒôcie': ['od do≈Çu d≈Çoni'],
          'przebieg': ['prosta'],
        },
        'health_line': {
          'obecno≈õƒá': ['brak'],
          'przebieg': ['prosta'],
        },
        'marriage_lines': {
          'ilo≈õƒá': ['1'],
          'kszta≈Çt': ['prosta'],
          'znaki': ['czysta'],
        },
        'children_lines': {
          'ilo≈õƒá': ['1-2'],
          'intensywno≈õƒá': ['≈õrednie'],
        },
      },
      'mounts': {
        'Mount of Jupiter': ['≈õredni'],
        'Mount of Saturn': ['≈õredni'],
        'Mount of Apollo': ['≈õredni'],
        'Mount of Mercury': ['≈õredni'],
        'Mount of Venus': ['≈õredni'],
        'Mount of Mars (upper)': ['≈õredni'],
        'Mount of Mars (lower)': ['≈õredni'],
        'Mount of Moon': ['≈õredni'],
      },
      'skin': {
        'tekstura': ['≈õrednia'],
        'wilgotno≈õƒá': ['normalna'],
        'kolor': ['r√≥≈ºowawa'],
      },
      'paznokcie': {
        'd≈Çugo≈õƒá': ['≈õrednie'],
        'kszta≈Çt': ['owalne'],
        'kolor': ['jasne'],
      },
    };
  }

  // Pozosta≈Çe metody pomocnicze...
  Future<bool> detectHandInImage() async {
    await Future.delayed(const Duration(milliseconds: 800));
    return _currentSessionDetectionState;
  }

  Future<String> determineHandType() async {
    await Future.delayed(const Duration(milliseconds: 300));
    return _currentHandType ?? (_random.nextBool() ? 'left' : 'right');
  }

  double evaluateLighting() {
    return 0.3 + (_random.nextDouble() * 0.7);
  }

  Map<String, dynamic> checkHandPosition() {
    if (_currentSessionDetectionState) {
      return {'isCorrect': true, 'message': 'Pozycja prawid≈Çowa'};
    }

    final random = _random.nextDouble();
    if (random > 0.6) {
      return {'isCorrect': false, 'message': 'Przybli≈º d≈Ço≈Ñ do kamery'};
    } else if (random > 0.4) {
      return {'isCorrect': false, 'message': 'Oddal d≈Ço≈Ñ od kamery'};
    } else if (random > 0.2) {
      return {'isCorrect': false, 'message': 'Wy≈õrodkuj d≈Ço≈Ñ w ramce'};
    } else {
      return {'isCorrect': false, 'message': 'Roz≈Ç√≥≈º palce szerzej'};
    }
  }

  bool checkHandStability() {
    return _currentSessionDetectionState || _random.nextDouble() > 0.4;
  }

  Future<bool> checkSkinColor(CameraController controller) async {
    try {
      print('üîç Sprawdzam kolor sk√≥ry...');
      bool hasSkinColor =
          _currentSessionDetectionState || _random.nextDouble() > 0.4;
      print('üé® Kolor sk√≥ry wykryty: $hasSkinColor');
      return hasSkinColor;
    } catch (e) {
      print('‚ùå B≈ÇƒÖd sprawdzania koloru sk√≥ry: $e');
      return false;
    }
  }

  Future<bool> checkPalmPosition(CameraController controller) async {
    try {
      print('üìç Sprawdzam pozycjƒô d≈Çoni...');
      bool isCentered =
          _currentSessionDetectionState || _random.nextDouble() > 0.3;
      print('üéØ D≈Ço≈Ñ wycentrowana: $isCentered');
      return isCentered;
    } catch (e) {
      print('‚ùå B≈ÇƒÖd sprawdzania pozycji: $e');
      return false;
    }
  }

  Future<double> checkLightLevel(CameraController controller) async {
    try {
      print('üí° Sprawdzam poziom ≈õwiat≈Ça...');
      final random = math.Random();
      double lightLevel = random.nextDouble();
      print('üåü Poziom ≈õwiat≈Ça: ${(lightLevel * 100).toInt()}%');
      return lightLevel;
    } catch (e) {
      print('‚ùå B≈ÇƒÖd sprawdzania ≈õwiat≈Ça: $e');
      return 0.0;
    }
  }
}
